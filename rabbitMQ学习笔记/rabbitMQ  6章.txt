set化架构策略

6.1 解决服务的扩展和容灾

6.2
	一个操作流程放在一个机房中(核心链路拆分出来)
		每个用户都可以在一个地方完成整个流程
		一个挂了，可以用其他服务
	
	流量路由：
	按照特殊的key(userID)进行路由，判断某次请求该路由到中心集群还是单元化集群

	中心集群：
	未进行单元化改造的服务(通常不在核心交易链路，比如)

	单元化集群：
	每个单元化集群只负责本单元内的流量处理，以实现流量拆分以及故障隔离；
	每个单元集群前期只存储本单元产生的交易数据，后续会做双向数据同步，
	实现容灾切换需求；

	中间件(RPC\KV\MQ等)：
	RPC：对于SET服务，调用封闭在SET内；对于非SET服务，沿用现有路由逻辑；
	KV：支持分SET的数据生产和查询；
	MQ：支持分SET的消息生产和消费；

	数据同步：
	全局数据(数据量小且变化不大，比如上家的菜品数据)部署在中心集群，其他
	单元化集群同步全局数据到本单元化内；
	未来演变为异地多活架构时，各单元化集群数据需要进行双向同步来实现容灾
	需要

	高效本地化服务
	利用前端位置信息采集和域名解析策略，将流量路由到最近的SET，提供最高效
	的本地化服务；
	比如O2O场景天然具有本地生产，本地消费的特点，更加需要SET化支持(外卖定位下订单找本地城市等)

	集装箱式的扩展：
	SET的封装支持更灵活的部署扩展性，比如SET一键创建/下线，SET一键发布等(docker)

	
6.4-5

	SET化重要原则：
	   对业务透明原则：
		SET话架构的实现对业务代码透明，业务代码层面不需要关系SET化规则，SET的部署等问题
	   SET切分规则：
		理论上。切分规则由业务层面按需定制；
		实际上，建议优先选最大的业务未读进行切分；
		比如海量用户的o2o业务，按用户位置信息进行切分。此外，接入层、逻辑层和
	      数据层都可以有独立的SET切分规则，有利于实现部署和运维成本的最优化
	   部署规范原则：
		一个SET并不一定只限制在一个机房，也可以跨机房或者跨地区部署；为了保证
	      灵活性，单个SET内机器数不宜过多(如不超过1000台物理机)
	
	rabbitMQ-SET化架构实现
	   SET化消息中间件架构实现(rabbitMQ双活)：

		使用rabbitMQ异步消息通信插件federation安装与配置：(节点与节点，集群与集群的异步通信)

		使用：
			安装插件
				rabbitmq-plugins enable rabbitmq_federation
				rabbitmq-plugins enable rabbitmq_federation_management
		注意：当你在一个cluster中使用federation插件，所有在集群中的nodes都需要
		安装federation插件
	

		使用rabbitMQ通信插件federation好处：
		federation插件是一个不需要cluster，而broker之间传输消息的高性能插件。
		federation插件可以在brokers或者cluster之间传输消息，链接的双方可以使用不同
		的users和virtual hosts、或者双方的rabbitmq和erlang版本不一致，federation
		插件使用AMQP协议通信，可以接收不连续的传输。


6.6 rabbitMQ-SET化架构环境构建

6.7 本章总结


7章：一线大厂基础组建封装和架构设计思路

本章导航：
	1、一线大厂的MQ组件实现思路和架构设计方案
	2、基础组件封装设计-迅速消息发送
	3、基础组件封装设计-确认消息发送
	4、基础组件封装设计-批量消息发送
	5、基础组件封装设计-延迟消息发送
	6、基础组件封装设计-顺序消息发送
	7、基础组件封装设计-事务消息发送
	8、消息幂等性保障-消息路由规则架构设计

<1> 7.1、一线大厂的MQ组件实现思路和架构设计方案(图：如下)

生产组件			各种组件
	 生产者缓存容器rabbitTemplateContainer
	 生产者消息确认组件rabbitTemplateConfirmCallBack
	 消息序列化解析器rapidMQMessageConverter
	 生产者发送处理器....rabbitBorkerProvider
	 发送器客户端producerClient
	 异步存储器asyncQueue
	 临时等待发送器MessageHolder
	 迅速消息设置器
	 延迟消息设置器
	 顺序
	 事务消息设置器
	 可靠性消息投递存储器messageStoreService

	 重试策略ReturnTryMessage 定时抓取器FetchMessage 失败处理器failMessage

//组件封装成一个jar包，给开发者使用，调用api即可


集群架构 keepalived高可用			keepalived高可用
	 HaProxy负载均衡器			HaProxy负载均衡器
	 内存镜像 磁盘镜像   ---双活集群---     内存镜像 磁盘镜像
				数据同步
	-----------------------------------------------------------RabbitMQ集群

消费端组件

	消费者监听容器 rabbitListenerContainerFactory
	消费者幂等性保障拦截器idempotentRabbitHandler
	消息存储路由选择器DBRoutingSelector //涉及分库分表
	消息异步处理器AsyncMessageInter //不一定需要马上处理
	消息幂等性服务IdempotentMessageService //操作幂等类 ;死信队列等
	消息异常处理机制。。。	//

------------------------------------------/////------

MQ组件实现功能点(一) //必须的，基本的需求

1、支持消息高性能的序列化转换、异步化发送消息	//做一个序列化组件
2、支持消息生产实例与消息实例的链接池缓存化，提升性能 //发消息使用池化处理
3、支持可靠性投递消息，保障消息的100%不丢失	     
4、支持消费端的幂等性操作，避免消费端重复消费的问题

MQ组件实现功能点(二) //扩展功能点
1、支持迅速消息发送模式，在一些日志收集/统计分析等需求下可以保证高性能， 
超高吞吐量。								//忽略消息百分百投递
2、支持延迟消息模式，消息可以延迟发送，指定延迟时间，用于某些延迟检查，
服务限流场景								//延迟检查，补偿等机制
3、支持事务消息，且100%保障可靠性投递，在金融行业单笔大金额操作时
会有此类需求								//

MQ组件实现功能点(三)
1、支持顺序消息，保证消息送达消费端的前后顺序，例如下订单等符合性操作
2、支持消息补偿，重试，以及快速定位异常/失败消息			//
3、支持集群消息负载均衡，保障消息落到具体SET集群的负载均衡	//多个集群，消息发送应该落入哪一个集群，前面需要封装一个路由规则，让消息送到对应集群，集群内部可以使用haproxy再次做一个路由，让消息送到对应节点上
4、支持消息路由策略，指定某些消息路由到指定的SET集群


<2> 7.4 消息发送模式

1、迅速消息发送
	a、迅速消息是指消息不进行落库存储，不做可靠性的保障
	b、在一些非核心消息、日志数据、或者统计分析等场景下比较合适
	c、迅速消息的优点就是性能最高，吞吐量最大
	
	图：
	DB----X---producer-----MQ Broker
2、确认消息发送 //图略
	类似于互联网大厂方案1

	业务数据库 和消息数据库---->BIZ service---->MQ----->confirm
	分布式定时任务--消息数据库--->重新投递---->超过次数-->失败处理

3 批量消息发送(一)
	a、批量消息是指我们吧消息放到一个集合中统一进行提交，
	b、期望消息在一个会话里，会有一个相同的会话ID，并提交消息的SIZE
	c、将这一批消息进行合并，对于channel而言就是发送一次消息。这种方式
	希望消费端在消费的时候，可以进行批量化的消费，针对于某一个原子业务
	的操作去处理，但是不保障可靠性，需要进行补偿机制。
	(可以保障原子性，但是不保障可靠性)

4 批量消息发送(二)
	BIZ DB
	MSG DB -------- BIZ Service
			
			sessionID
			ThreadLocal
	Msg DB  --------MessageHoder  --------- MQBorker ------consumer

//

5 延迟消息发送
	a、延迟消息相对简单，就是我们在message封装的时候添加delayTime属性即可，(使用rabbitMQ的延迟插件即可)
	使得我们的消息可以进行延迟发送，根据具体的业务场景也可以很好的使用得到！
	b、场景举例：
		A、比如你在电商平台买到的商品签收后，不点击确认支付，呢么系统自动
		会在7天(一定时间)去进行支付操作。
		B、还有一些自动超时作废的场景，你的优惠券/红包有使用时间限制，也可以
		用延迟消息机制

<3> 消息发送模式--顺序消息(一)
	
1、顺序消息，比较类似于批量消息的实现机制，但是也有些不同
2、我们要保障以下几点：
	a、发送的顺序消息，必须保障消息投递到同一个队列，且这个消息只能有一个(独占模式)
	b、然后需要统一提交(可能是合并成一个大消息，也可能拆分为多个消息)，并且所有
	消息的会话ID一致   //不推荐合并成一个大消息，推荐拆分
	c、添加消息属性：顺序标记的序号、和本次顺序消息的SIZE属性，进行落库操作
	//生产者投递7到8次，消费者也获取7到8次，每次获取之后并不直接消费，而是拿到消息进行落库；
	d、并行进行发送给自身的延迟消息(注意带上关键属性：会话ID、SIZE)进行后续处理消费
	//投递给自己一个延迟消息
	总结：生产端发送一批消息，分6次投递，发送给MQ，然后消费端我这一个队列监听到这6条消息，并不直接消费，
	而是将这6条消息进行入库：比如说：收到第一条消息后：取到一些关键的属性：统一的会话ID SIZE等；直接发送一个
	延迟投递消息：比如说5分钟之后再去做后续处理(也就是5分钟之后能保证将这批消息都入库完)；然后投递一下延迟消息
	带上会话ID和SIZE属性就可以了
	e、当收到延迟消息后，根据会话ID，SIZE属性抽取数据库数据进行处理即可
	f、定时轮询补偿机制，对于异常情况
	(备注：比如生产端消息没有完全投递成功，或者消费端落库异常导致消费端落库后缺少消息条目的情况)
	(需要进行一些补偿机制)
3、顺序消息(三) 图(想了解，看视频图)
	生产端和消费端都要进行入库操作，而且都做消息补偿机制处理(定时任务操作)


//如果顺序消息也跟批量消息一样进行发送，呢么消费端要做一些顺序消息消费的业务逻辑，这样做是非常耗时的，不推荐
//发顺序消息的时候需要将这7个小消息拆开，消费端只要保存好这七个小消息；保证一个顺序消费就可以了；在不影响
//消费进度，不阻塞消费者的情况下；这样才是对性能最好的提升

与批量消息的区别：
//批量消息不需要考虑顺序问题(合成一个整体就行)，但是顺序消息需要考虑顺序问题，
//如果合成一个大消息，消费端还需要进行拆分的业务逻辑，影响性能


<4> 事务消息
1、事务消息：相对使用比较少见，在互联网金融行业：面对单笔大额的现金流交易时遇到过：
比如单笔转账超过一个上限的时候，我们就希望这个消息优先级最高，并且可靠性要求达到100%
，当前我们的系统和银行端系统又要兼顾才行，所以也会有一些补偿机制，主动发起银行查询
指令机制等。
//也就是自身系统保证100%
//A客户---转账---B账户  本业务系统可以100% ，但是需要银行呢边发送成功
//半小时内给一个结果，10分钟后就要紧急处理，运维向银行反映

2、为了保障性能的同时，也支持事务。我们并没有选择传统的rabbitMQ事务和spring集成的机制，
因为在性能测试的过程中，效果并不理想，非常消耗系统资源且会出现阻塞等情况，在高峰期也是
一定程度上影响MQ集群的性能。

3、解决方案：
	a、我们采用列斯可靠性投递的机制，也就是做补偿机制。
	b、但是我们的数据源必须是同一个，也就是业务操作DB1数据库和消息记录DB2数据库
	使用同一个数据源
	----------------？
	c、然后利用重写spring dataSourceTranslationManager，在本地事务提交的时候进行
	发送消息，但是也有可能事务提交成功但是消息发送失败，这个时候就需要进行补偿了。
	//保障本地事务提交 保障入库原子性；之后发送消息并不提供原子性，做补偿即可

	d、rapidTranslationManager extends DataSourceTranslationManager{
		doCommit(DefaultTransactionStatus status){
			super.doCommit(status);
			//保障了以上提交的事务原子性，同时提交
			List<MessageSender> messages = MessageHolder.clear();
			messages.forEach(AsyncQueue::submit);
			//这个入库后，发送可能失败
		}

	}
	e、图
	BIZ DB
	MSG DB <----- 入库成功(threadLocal messageHolder 
				DataSourceTransactionManager
				commit and sendMessage)--------->发送消息
	
	分布式定时任务轮询

<5> 消息幂等性

1、消息幂等性的必要性
	a、保障消息幂等性，这是我们再使用MQ中至关重要的环节
	b、可能导致消息出现非幂等性的原因：
		1、可靠性消息投递机制(如网络闪断：呢么消费端可能受到两次相同的消息)
		2、MQ Broker服务于消费端传输消息的过程中的网络抖动
		3、消费端故障或异常

	c、图
	统一ID生成服务
		|
		|
	    Send Msg					     //每个相同消息落库还是到指定数据库
	    upstream service ----->MQ broker <----listener--ID规则路由组件---routing--->
	   本地ID生成服务					  |
								  |
								  |
						          ----------------
							  MSG DB...(根据hash算法进行分库分表等)
							  根据数据库主键支持幂等性操作
	   
							  方案2：使用redis来：可以做双缓存，解决数据库与缓存同步的一致性
<6> 本章小结
	1 MQ基础组件服务的核心解决方案和架构设计思路
	2 消息投递方式，以及消费的幂等性保障



8章

rabbitMQ课程总结十步走

1 掌握MQ在各种场景下的应用

2 熟悉了解/深入探究主流消息中间件特点、架构、原理、底层机制

3 学习rabbit基础原理和API级别的使用

4 巧妙运用rabbit高级特性服务于你的应用服务、架构设计

5 学习MQ与spring体系整合，更高效的实现MQ与应用服务的集成

6 构建高可靠性的MQ服务、搭建完备的平台化体系

7 紧密结合互联网大厂的架构设计思路，构建自己的架构设计思路

8 解决各种场景、需求下的MQ中间件设计与落地

9 封装基础组件、让别人站在你的肩膀上编码



思考：
如何实现不同数据库
	同一个数据源操作(保证原子性)

redis入库：实现数据同步机制 //再增加一个缓存




